From d3b880e787ed77f31a9d3b6ba797db74c5739d76 Mon Sep 17 00:00:00 2001
From: Costin Lupu <costin.lupu@cs.pub.ro>
Date: Thu, 11 Nov 2021 17:11:19 +0200
Subject: [PATCH] cloning: profiling

---
 src/profile.h | 159 ++++++++++++++++++++++++++++++++++++++++++++++++++
 src/rdb.c     |  17 +++++-
 2 files changed, 175 insertions(+), 1 deletion(-)
 create mode 100644 src/profile.h

diff --git a/src/profile.h b/src/profile.h
new file mode 100644
index 0000000..9366ae5
--- /dev/null
+++ b/src/profile.h
@@ -0,0 +1,159 @@
+/******************************************************************************
+ * profiling functions
+ *
+ * Copyright (c) 2020 Costin Lupu
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __XENCLONE_PROFILE_H__
+#define __XENCLONE_PROFILE_H__
+
+#include <stdio.h>
+#include <time.h>
+
+#define LIB_PROFILING 1
+
+#if LIB_PROFILING
+
+#define __noinstrument __attribute__((no_instrument_function))
+
+#define NSECONDS_IN_SEC 1000000000
+#define USECONDS_IN_SEC 1000000
+#define MSECONDS_IN_SEC 1000
+
+#define NSECONDS_IN_MSEC    (NSECONDS_IN_SEC / MSECONDS_IN_SEC)
+
+
+static inline __noinstrument
+time_t timespec_nsec(struct timespec *t)
+{
+	return t->tv_sec * NSECONDS_IN_SEC + t->tv_nsec;
+}
+
+static inline __noinstrument
+unsigned long timespec_usec(struct timespec *t)
+{
+	return ((unsigned long) t->tv_sec) * USECONDS_IN_SEC + ((unsigned long) t->tv_nsec) / 1000;
+}
+
+static inline __noinstrument
+time_t timespec_diff_nsec(struct timespec *start, struct timespec *end)
+{
+	return timespec_nsec(end) - timespec_nsec(start);
+}
+
+static inline __noinstrument
+unsigned long timespec_diff_usec(struct timespec *start, struct timespec *end)
+{
+	unsigned long _end = timespec_usec(end);
+	unsigned long _start = timespec_usec(start);
+//	return (_end > _start) ? _end - _start : _start - _end;
+	return _end - _start;
+}
+
+static inline __noinstrument
+double timespec_diff_msec(struct timespec *start, struct timespec *end)
+{
+	return (double) timespec_diff_nsec(start, end) / NSECONDS_IN_MSEC;
+}
+
+static inline __noinstrument
+double timespec_diff_sec(struct timespec *start, struct timespec *end)
+{
+	return (double) timespec_diff_nsec(start, end) / NSECONDS_IN_SEC;
+}
+
+
+#define PROFILE_PREFIX   "REDIS_TRACE "
+
+extern __thread int __profile_lvl;
+
+
+#define PROFILE_NESTED_TICK(str) \
+	{ \
+		struct timespec __profile_tick; \
+		struct timespec __profile_tock; \
+		double __profile_val; \
+		__profile_lvl++; \
+		clock_gettime(CLOCK_MONOTONIC, &__profile_tick); \
+
+#define PROFILE_NESTED_TOCK_MSEC(_str) \
+		clock_gettime(CLOCK_MONOTONIC, &__profile_tock); \
+		__profile_val = timespec_diff_msec(&__profile_tick, &__profile_tock); \
+		fprintf(stderr, PROFILE_PREFIX "%11.6lf %d %s\n", \
+			__profile_val, __profile_lvl, _str); \
+		__profile_lvl--; \
+	}
+
+#define PROFILE_TS_SEC(fmt, ...) \
+	do { \
+        struct timespec __profile_ts; \
+		clock_gettime(CLOCK_REALTIME, &__profile_ts); \
+		fprintf(stderr, "%ld.%09ld " fmt "\n", \
+            __profile_ts.tv_sec, __profile_ts.tv_nsec, ## __VA_ARGS__); \
+	} while (0)
+
+
+#if 1
+struct profile {
+	struct timespec start;
+	struct timespec stop;
+};
+
+static inline int profile_start(struct profile *p)
+{
+	return clock_gettime(CLOCK_REALTIME, &p->start);
+}
+
+static inline int profile_stop(struct profile *p)
+{
+    return clock_gettime(CLOCK_REALTIME, &p->stop);
+}
+
+static inline double profile_msec(struct profile *p)
+{
+	return timespec_diff_msec(&p->start, &p->stop);
+}
+
+static inline time_t profile_sec(struct profile *p)
+{
+	return timespec_diff_sec(&p->start, &p->stop);
+}
+
+#define PROFILE_FILE "/root/xl.profile.out"
+
+extern int libxl_domain_create_new_profile_trigger;
+
+#define PROFILE_PRINT_MSEC(p, fmt, ...) \
+    do { \
+        if (libxl_domain_create_new_profile_trigger) { \
+            FILE *fp = fopen(PROFILE_FILE, "a"); \
+            fprintf(fp, "%.6lf" fmt "\n", profile_msec(p), ## __VA_ARGS__); \
+            fclose(fp); \
+        } \
+    } while (0)
+
+#endif
+
+#else
+#define __noinstrument
+
+#define profile_start(p)
+#define profile_stop(p)
+
+#define PROFILE_PRINT_MSEC(p, fmt, ...)
+#endif
+
+#endif /* __XENCLONE_PROFILE_H__ */
diff --git a/src/rdb.c b/src/rdb.c
index acbba4b..ee275bd 100644
--- a/src/rdb.c
+++ b/src/rdb.c
@@ -32,6 +32,7 @@
 #include "zipmap.h"
 #include "endianconv.h"
 #include "stream.h"
+#include "profile.h"
 
 #include <math.h>
 #include <sys/types.h>
@@ -42,6 +43,8 @@
 #include <sys/stat.h>
 #include <sys/param.h>
 
+__thread int __profile_lvl = -1;
+
 #define rdbExitReportCorruptRDB(...) rdbCheckThenExit(__LINE__,__VA_ARGS__)
 
 extern int rdbCheckMode;
@@ -1326,6 +1329,7 @@ werr:
 int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) {
     pid_t childpid;
     long long start;
+    const char *label;
 
     if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;
 
@@ -1334,13 +1338,23 @@ int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) {
     openChildInfoPipe();
 
     start = ustime();
-    if ((childpid = fork()) == 0) {
+
+    PROFILE_NESTED_TICK();
+    childpid = fork();
+    label = (childpid == 0) ? "fork child" : "fork parent";
+    PROFILE_NESTED_TOCK_MSEC(label);
+
+
+    if (childpid == 0) {
         int retval;
 
+        PROFILE_NESTED_TICK();
         /* Child */
         closeListeningSockets(0);
         redisSetProcTitle("redis-rdb-bgsave");
+        PROFILE_NESTED_TICK();
         retval = rdbSave(filename,rsi);
+        PROFILE_NESTED_TOCK_MSEC("save");
         if (retval == C_OK) {
             size_t private_dirty = zmalloc_get_private_dirty(-1);
 
@@ -1353,6 +1367,7 @@ int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) {
             server.child_info_data.cow_size = private_dirty;
             sendChildInfo(CHILD_INFO_TYPE_RDB);
         }
+        PROFILE_NESTED_TOCK_MSEC("total");
         exitFromChild((retval == C_OK) ? 0 : 1);
     } else {
         /* Parent */
-- 
2.20.1

